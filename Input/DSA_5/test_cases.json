{
    "1": "Question: `Write a class to implement LRU Cache with put and get methods.`\n\n--Test Cases Start--\n```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.order = []\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            self.order.remove(key)\n            self.order.append(key)\n            return self.cache[key]\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.order.remove(key)\n        elif len(self.cache) >= self.capacity:\n            oldest = self.order.pop(0)\n            del self.cache[oldest]\n        self.cache[key] = value\n        self.order.append(key)\n\ndef test_solution():\n    cache = LRUCache(2)\n\n    # Test case 1: Adding elements to the cache\n    cache.put(1, 1)\n    cache.put(2, 2)\n    assert cache.get(1) == 1  # returns 1\n    assert cache.get(2) == 2  # returns 2\n\n    # Test case 2: Cache eviction\n    cache.put(3, 3)  # evicts key 2\n    assert cache.get(2) == -1  # returns -1 (not found)\n\n    # Test case 3: Updating existing key\n    cache.put(1, 10)  # updates key 1\n    assert cache.get(1) == 10  # returns 10\n\n    # Test case 4: Adding more elements than capacity\n    cache.put(4, 4)  # evicts key 3\n    assert cache.get(3) == -1  # returns -1 (not found)\n    assert cache.get(4) == 4  # returns 4\n\n    # Test case 5: Order of elements\n    cache.put(5, 5)  # evicts key 1\n    assert cache.get(1) == -1  # returns -1 (not found)\n    assert cache.get(5) == 5  # returns 5\n\n    print(\"All test cases passed!\")\n\ntest_solution()\n```\n--Test Cases End--\n\n--Constrains Start--\n- The class should be named `LRUCache`.\n- The class should have methods `put(key: int, value: int)` and `get(key: int) -> int`.\n- The constructor should take an integer `capacity` as input.\n- The `get` method should return the value associated with the key if it exists, otherwise return -1.\n- The `put` method should add a key-value pair to the cache, evicting the least recently used item if the cache exceeds its capacity.\n--Constrains End--",
    "2": "Question: `Write a function to reverse a linked list.`\n\n--Test Cases Start--\n```python\nclass ListNode:\n    def __init__(self, value=0, next=None):\n        self.value = value\n        self.next = next\n\ndef reverse_linked_list(head):\n    prev = None\n    current = head\n    while current:\n        next_node = current.next\n        current.next = prev\n        prev = current\n        current = next_node\n    return prev\n\ndef test_solution(solution):\n    passed = []\n    not_passed = []\n\n    # Helper function to create a linked list from a list\n    def create_linked_list(elements):\n        if not elements:\n            return None\n        head = ListNode(elements[0])\n        current = head\n        for value in elements[1:]:\n            current.next = ListNode(value)\n            current = current.next\n        return head\n\n    # Helper function to convert linked list to a list for easy comparison\n    def linked_list_to_list(head):\n        result = []\n        current = head\n        while current:\n            result.append(current.value)\n            current = current.next\n        return result\n\n    # Test case 1: Normal case\n    input_list = [1, 2, 3, 4, 5]\n    expected_output = [5, 4, 3, 2, 1]\n    head = create_linked_list(input_list)\n    if linked_list_to_list(solution(head)) == expected_output:\n        passed.append(\"Solution has passed test case with input \" + str(input_list))\n    else:\n        not_passed.append(\"Solution has not passed test case with input \" + str(input_list) + \" expected \" + str(expected_output))\n\n    # Test case 2: Empty list\n    input_list = []\n    expected_output = []\n    head = create_linked_list(input_list)\n    if linked_list_to_list(solution(head)) == expected_output:\n        passed.append(\"Solution has passed test case with input \" + str(input_list))\n    else:\n        not_passed.append(\"Solution has not passed test case with input \" + str(input_list) + \" expected \" + str(expected_output))\n\n    # Test case 3: Single element list\n    input_list = [1]\n    expected_output = [1]\n    head = create_linked_list(input_list)\n    if linked_list_to_list(solution(head)) == expected_output:\n        passed.append(\"Solution has passed test case with input \" + str(input_list))\n    else:\n        not_passed.append(\"Solution has not passed test case with input \" + str(input_list) + \" expected \" + str(expected_output))\n\n    # Test case 4: Two elements list\n    input_list = [1, 2]\n    expected_output = [2, 1]\n    head = create_linked_list(input_list)\n    if linked_list_to_list(solution(head)) == expected_output:\n        passed.append(\"Solution has passed test case with input \" + str(input_list))\n    else:\n        not_passed.append(\"Solution has not passed test case with input \" + str(input_list) + \" expected \" + str(expected_output))\n\n    # Test case 5: List with duplicate values\n    input_list = [1, 2, 2, 1]\n    expected_output = [1, 2, 2, 1]\n    head = create_linked_list(input_list)\n    if linked_list_to_list(solution(head)) == expected_output:\n        passed.append(\"Solution has passed test case with input \" + str(input_list))\n    else:\n        not_passed.append(\"Solution has not passed test case with input \" + str(input_list) + \" expected \" + str(expected_output))\n\n    return passed, not_passed\n```\n--Test Cases End--\n\n--Constrains Start--\n- The Function should be named 'reverse_linked_list' [same as used in test case definitions]\n- The Function should take a single parameter, which is the head of the linked list (ListNode).\n- The Function should output the head of the reversed linked list (ListNode).\n--Constrains End--"
}